---
id: 77a6ac4a-3a4a-4db5-919e-19c719533bf5
title: My Baby Steps to OAuth 2.0 Hell (or Should I Call It Heaven)
abstract: Securing our HTTP API endpoints are one of the biggest challenges we face
  when writing so-called modern applications and this is where the OAuth 2.0 enters.
  In this post, I will highlight the things that I have found vital for the last couple
  of months when I have been working on an OAuth 2.0 Server implementation in .NET
  Framework.
created_at: 2014-03-16 13:05:00 +0000 UTC
tags:
- ASP.NET Web API
- HTTP
- OAuth
slugs:
- my-baby-steps-to-oauth-2-0-hell-or-should-i-call-it-heaven
---

<p>Securing our HTTP API endpoints are one of the biggest challenges we face when writing so-called modern applications. There are multiple concerns that we need to cover when security is the issue but for those modern applications, the concerns are much bigger because you are no more under your trusted subsystem in your organization domain. <a href="http://leastprivilege.com/">Dominick Baier</a>, Mr. Identity, has covered this topic several times:</p> <ul> <li><a href="http://vimeo.com/43603474">Securing ASP.NET Web APIs</a></li> <li><a href="http://vimeo.com/68327244">Securing ASP.NET Web APIs and HTTP Services</a></li></ul> <p>This is where the OAuth 2.0 enters. <a href="http://tools.ietf.org/html/rfc6749">OAuth 2.0</a> is a specification and defines an authorization framework which enables you to give limited access to the third party applications on behalf of the resource owner through one of the defined flows. I’m not going to duplicate the RFC 6749 here but I will highlight the things that I have found vital for the last couple of months when I have been working on an OAuth 2.0 Server implementation in .NET Framework. So, this post is mostly a brain dump.</p> <p>First of all, there are a few terms that you have to know before you dip your toes in the OAuth water: <ul> <li>Resource server: The server that holds the resource.  <li>Resource owner: The user which owns the specific resources. <li>Authorization server: A server that authenticates the resource owner and issues access tokens to the client.  <li>Client: The application that requests access on a resource on behalf of the resource owner.</li></ul> <p>There are more terms that you will see when you start reading the specification but the above list should be enough for this blog post. From this point on, I will go through a few bullet points which come in handy as a checklist when designing an OAuth 2.0 authorization server and an HTTP service backed by that authorization server.</p> <h3>Give Scope-based Permissions</h3> <p>The best thing that OAuth specifies is the distinction between the client and the application (resource server) and this gives you a chance to think about your structure again after you read the specification. The application is where you handle your business and expose the certain data. The data exposed here may be tied to a resource owner (for example, user’s hotel bookings) but it doesn’t have to be. That data can be something that your application deals with directly with the user context (for example, the list of hotels).</p> <p>You should probably see where I’m going with this. Each of your exposed HTTP endpoints need different level of access grant, permission, whatever you want to call it. The OAuth 2.0 helps you handles this as well in a standard way: scopes. A scope defines a level of access that the client acquired. In each OAuth flow, the client specifies which scopes it needs to obtain. Assume that your application is handles data for a travel and tourism company (just like Expedia) and the scopes would be similar to below list:</p> <ul> <li>Reading user hotel reservations</li> <li>Changes to user hotel reservations</li> <li>Making hotel reservations on behalf of a user</li></ul> <p>This list can go on. Handling access to a resource based on scopes in your HTTP service layer gives you a natural way of dealing with the resources. <a href="https://github.com/thinktecture/Thinktecture.IdentityModel">Thinktecture.IdentityModel</a> library has a nice little authorization attribute for your <a href="http://www.asp.net/web-api">ASP.NET Web API</a> applications: <a href="https://github.com/thinktecture/Thinktecture.IdentityModel/blob/master/source/Thinktecture.IdentityModel.WebApi/ScopeAuthorizeAttribute.cs">ScopeAuthorizeAttribute</a>. This attribute allows you to protect the each HTTP service endpoint based on required scopes.</p> <h3>Every Endpoint Should Require Authentication</h3> <p>It is certainly a valid situation if you have some endpoints which don’t require resource owner context. For example, a client application may want to get a list of hotels in a region (going with my Expedia sample here again). In that case, resource owner permission is not necessary. So, those endpoints can be exposed publicly without needing any type of authentication and authorization? Absolutely not! In such an environment, don’t ever design your HTTP service in this way. I have found out that requiring an identity in each endpoint of your HTTP service is vital. For cases where you see that resource owner context is not necessary, the client application can obtain the access token through the <a href="http://tools.ietf.org/html/rfc6749#section-4.4">Client Credentials Grant</a> and hit your HTTP service endpoints with the access token obtained through the client credentials grant.</p> <h3>DO Validate the Redirect URI</h3> <p>This is a must! You should always validate the redirect_uri parameter and try to match it with the client’s pre-registered redirect URIs for <a href="http://tools.ietf.org/html/rfc6749#section-4.1">Authorization Code Grant</a> and <a href="http://tools.ietf.org/html/rfc6749#section-4.2">Implicit Grant</a> requests. Unless you do this, your authorization server will be very dangerous! Potentially, you could be ending up redirecting the access token to anywhere. </p> <h3>Only One Grant Type + Client Credentials Grant for a Client</h3> <p>Besides the client credentials grant, only allow one grant type for a client. When you think about it, you should see that a client only needs one type of grant. A server based client application (a web application, for instance) will need <a href="http://tools.ietf.org/html/rfc6749#section-4.1">Authorization Code Grant</a>. An iPhone application will need <a href="http://tools.ietf.org/html/rfc6749#section-4.2">Implicit Grant</a>. So, on the way to issuing an access token, validate the grant type as well.</p> <h3>References</h3> <ul> <li><a href="http://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework (RFC 6749)</a> <li><a href="http://tools.ietf.org/html/rfc6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage (RFC 6750)</a> <li><a href="http://tools.ietf.org/html/draft-ietf-oauth-dyn-reg-16">OAuth 2.0 Dynamic Client Registration Core Protocol (Draft v16)</a> <li><a href="http://vimeo.com/68331687">OAuth2 – The good, the bad and the ugly</a> <li><a href="http://www.cloudidentity.com/blog/2013/07/30/securing-a-web-api-with-windows-server-2012-r2-adfs-and-katana/">Securing a Web API with Windows Server 2012 R2 ADFS and Katana</a> <li><a href="http://www.asp.net/aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server">OWIN OAuth 2.0 Authorization Server</a> <li><a href="https://github.com/DotNetDoodle/DotNetDoodle.OAuthServer">DotNetDoodle.OAuthServer - An OWIN based OAuth Server Implementation (A playground implementation)</a> <li><a href="https://github.com/thinktecture/Thinktecture.AuthorizationServer">Thinktecture.AuthorizationServer - An implementation of an OAuth2 authorization server</a> <li><a href="http://leastprivilege.com/2013/11/23/thinktecture-identitymodel-client-v1-0/">Thinktecture.IdentityModel.Client - .NET OAuth Client</a> <li><a href="http://leastprivilege.com/2013/11/25/dissecting-the-web-api-individual-accounts-templatepart-1-overview/">Dissecting the Web API Individual Accounts Template–Part 1: Overview</a> <li><a href="http://leastprivilege.com/2013/11/26/dissecting-the-web-api-individual-accounts-templatepart-2-local-accounts/">Dissecting the Web API Individual Accounts Template–Part 2: Local Accounts</a> <li><a href="http://leastprivilege.com/2013/11/26/dissecting-the-web-api-individual-accounts-templatepart-3-external-accounts/">Dissecting the Web API Individual Accounts Template–Part 3: External Accounts</a> <li><a href="http://social.technet.microsoft.com/wiki/contents/articles/12370.step-by-step-guide-for-setting-up-a-windows-server-2012-domain-controller.aspx">Step-by-Step Guide for Setting Up A Windows Server 2012 Domain Controller</a> <li><a href="http://blogs.technet.com/b/ad/archive/2013/07/10/extending-device-support-in-active-directory.aspx">Extending device support in Active Directory</a> <li><a href="http://blogs.technet.com/b/ad/archive/2013/04/22/developer-preview-of-oauth-code-grant-and-aal-for-windows-store-apps.aspx">Developer Preview of OAuth Code Grant and AAL for Windows Store Apps</a></li></ul>  