---
id: a49a2947-23b4-42dc-9584-f10e32eae655
title: Profiling ASP.NET 5 Applications with ANTS Performance Profiler
abstract: ANTS Performance Profiler from Redgate supports ASP.NET 5 applications running
  on DNX and it allows you to profile your ASP.NET 5 applications to spot performance
  problems in a really easy and unobtrusive way. In this blog post, I will show you
  how it can help you with a sample.
created_at: 2015-10-20 19:16:00 +0000 UTC
tags:
- .net
- ASP.Net
- ASP.NET 5
- HTTP
slugs:
- profiling-asp-net-5-applications-with-ants-performance-profiler
---

<p>One of the biggest challenges with <a href="http://www.tugberkugurlu.com/tags/asp-net-5">ASP.NET 5</a> is the fact that most of the existing tools and libraries are not supporting the ecosystem as it’s a complete revamp of the runtime and some of the concept we have been used to in both development and production. However, some tools catch up quite surprisingly fast and one of those tools is <a href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/">ANTS Performance Profiler</a> from <a href="http://www.red-gate.com/">Redgate</a> and <a href="https://www.simple-talk.com/blogs/2015/06/04/beta-support-for-asp-net-5-dnx-projects-in-ants-profilers/">it allows you to profile your ASP.NET 5 applications</a> to spot performance problems in a really easy and unobtrusive way.</p> <blockquote> <p>ANTS Performance Profiler is a paid tool but it has a 14-day free trial option. Also, if you are a <a href="https://mvp.microsoft.com/">Microsoft MVP</a>, you can get a free license for this tool. If this sounds like you, visit <a href="https://www.red-gate.com/community/">Redgate community page</a> and claim your free license by following the instructions there.</p></blockquote> <p>When you open up ANTS .NET Performance Profiler, you should immediately notice the ASP.NET 5 section:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/2d68dd54-7cdd-48ed-b3c9-1f96b893af5a.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/5afc5174-e4f8-46e1-8948-f58952dc5fe6.png" width="644" height="405"></a></p> <p>From there, it’s all pretty straight forward to move along. Just select the project.json file path for your application and the DNX runtime that your application should run on. Optionally, you can configure other profiling options like collecting additional performance counters. When you are ready, you can just hit the "Start profiling" button and go!</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/f8a0fff6-bf85-4179-9a41-8a83d4a37bd8.gif"><img title="2015-10-20_19-31-35" style="display: inline" alt="2015-10-20_19-31-35" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/36c46bda-9fd5-48ec-a76f-c3c682acccb8.gif" width="640" height="341"></a></p> <p>One feature that I am in love with here is incoming HTTP requests view. The tool knows about received requests during the profiling session and you can see where they started on the class stack:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/4c11fd61-d6a3-4c5b-b713-e98a707aa3cb.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/528c6bf2-4a53-4435-ac75-5e81591a5b54.png" width="644" height="171"></a></p> <p>You can see that you are able to see the hint count and average times for request to complete. From here, I can jump straight to the HTTP request that I am interested in:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/d795f9d4-cff9-4674-ba67-13432ecabd89.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/a20a61ba-a8e3-4549-81b6-7b900e04bfdd.png" width="644" height="181"></a></p> <p>Notice that it starts with ErrorHandlerMiddleware on the call tree. The reason is that it’s the first middleware in my middleware chain and I configured ANTS Performance Profiler to only show me the methods with source as you can see at top on the screenshot above. So, it filtered the call stack a little for me and I can look at the source of the actual methods if I want to:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/067ea74b-1c25-4b62-b9ef-69e961361f30.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/3e08d4f0-b4d5-487d-849b-219834f9e8db.png" width="644" height="213"></a></p> <h3>Profiling Bottlenecks</h3> <p>ANTS Performance Profiler makes it extremely easy to spot bottlenecks in your applications. I will show you a sample based on a personal experience I had before but I will fake the problem here a little :) However, the narrative is quite similar to what I went through but I struggled a lot more that this as I didn’t use a profiling tool to understand the problem.</p> <p>In my simple sample, I have an object which I know that it will take a bit time to construct because of its nature and I am fine with that. The good news is that this object is thread safe and I can share it among multiple requests. However, I am seeing big CPU spikes when I run my application. To spot the problem, I ran a profiling session with ANTS Performance Profiler. Right after stopping the profiling session, I landed on the problem. So easy and that makes me perfectly happy!</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/2295a6e0-7551-4e2f-90ce-ed40b0a23b6a.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/06120db4-1809-473b-838d-bc18ed0fd519.png" width="644" height="445"></a></p> <p>I know that the constructor could have been the problem but I really didn’t expect it to be this much. I know that it takes around ~2 seconds to be constructed under a good functioning CPU but when I look at the actual time spent there, it’s around ~32 seconds:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/0337728c-8e76-4946-9773-0f131d9845c3.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/cad49bb3-e223-45ca-a4a1-188ee5ab62b9.png" width="644" height="97"></a></p> <p>So, that’s not normal at all and as soon as I saw that number, I turned my eyes to hit count. There, I saw that it has been called 9 times! That’s way more than expected as I only wanted a single object for the whole application. I am only constructing this object through my IoC container and in this case, it should only mean that my IoC container has been configured wrong. When I look at the configuration of my services, I saw the actual problem:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/1d9bcd47-2ed2-4ab7-943e-f228bb48cb85.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/bf9d7916-5133-41be-b5f6-f5cae29de239.png" width="644" height="92"></a></p>   <p>This should have been registered as singleton but as you can see, it is scoped per request which causes it to be constructed for each request. It is not like I wouldn’t be able to spot this without the profiling tool but it makes it so much easy and fast. I actually wanted to try this as a sample because I had the first hand experience on this problem. Believe me! Spotting the exact problem was so much harder through debugging!</p> <p>OK, if we go back to our issue again: changing the dependency registration to make it singleton solves the problem nicely:</p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/dd1b257f-a6eb-4859-b157-add1cd357140.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/59042960-ddf4-4544-9a86-5a67d7caf2e8.png" width="644" height="108"></a></p> <p>Check out <a href="http://documentation.red-gate.com/display/APP9/ANTS+Performance+Profiler+9+documentation?_ga=1.196306668.1381018878.1442933918">ANTS Performance Profiler documentation</a> for more information about this tool. The other perfect resource on .NET performance profiling is <a href="https://www.red-gate.com/community/books/practical-performance-profiling">Practical Performance Profiling book</a> which you can download the PDF version for free.</p> <p>Happy profiling .NET people :)</p>  