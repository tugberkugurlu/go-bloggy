---
title: Software Applications Should Work Like Restaurants
abstract: This is a brain dump blog post which I usually don't do but I needed to
  get this out of my chest. Restaurants and software applications have some common
  characteristics in terms of how they need to work and this post highlights some
  of them.
created_at: 2015-02-14 23:55:00 +0000 UTC
tags:
- HTTP
- Software
slugs:
- software-applications-should-work-like-restaurants
---

<p>I went to a restaurant today and one particular thing struck me there. It made me really interested in writing this brain dump blog post. It was about the fact that restaurants and software applications have a lot in common in terms of how they (should) function. One common characteristic I know is coming from very clever and kind <a href="http://blog.stevensanderson.com/">Steve Sanderson</a> on <a href="http://channel9.msdn.com/Events/TechDays/Techdays-2012-the-Netherlands/2287">his talk on asynchronous web applications</a> and I won’t go into details on that. I would like to focus on the other common functional characteristic I noticed today but before that, here is a brief background of the story :)</p> <p>After I walked through the door and sit on a table, the next thing I did was order beers and some onion rings. Then, I went to my table with beers and nearly less than 2 minutes later, the onion rings were in front of me. All looks perfect. These were well-cooked, yummy onion rings. </p> <p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/8fc5f230-c599-49bf-b9aa-b780abbd8157.jpg"><img title="2015-02-14 18.53.11" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="2015-02-14 18.53.11" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/e301d391-2d8a-438a-8b9a-05336f8fc972.jpg" width="644" height="484"></a></p> <p>After a few sips and finishing the onion rings, I ordered my main course which was a medium-well cooked, 20oz steak. It took about 10 to 15 minutes for that to arrive. At the end of the day, I was happy. It was all OK and I didn’t mind waiting for the steak more than onion rings because it made sense.</p> <p>Why am I explaining all these? Because this is how most of the software applications should function, especially the HTTP based applications. The typical software application has to deal with data which is represented through the domain of the application. One way or the other, software application users interact with this data. The important fact here is that not all of this data is the same; just like the onion rings and steak were not the same for the restaurant. So, you shouldn’t make the assumption of serving all of the data in the same manner through your software application.</p> <h3>Onion Rings Case</h3> <p>Let’s go back to my restaurant example. It was obvious to me that the restaurant fried the rings before they are being ordered. They were doing this because they know the general order rate for the onion rings. So, they were making a judgment call and were frying the rings before they are being ordered. This raises the the risk of serving the onion rings to each customer with a different heat and freshness level. However, this doesn’t matter that much because:</p> <ol> <li>The restaurant has an expected number in mind and they were not going crazy about this (like frying millions of onion rings). So, they were holding the balance.</li> <li>The first priority here was to serve good product. Second thing here is to solve the problem of serving the rings fast and spending the least amount of staff resources. All of these two were possible to achieve at the same time.</li></ol> <p>The same concept they applied there should be applied in your applications and I bet most of us doing this already. In some cases, users just don’t care about the accuracy and the freshness of the application data. Take the Foursquare example. Do I care if I don’t see the newly-created coffee shop inside my search results when I try to find the nearest coffee shops? You mostly don’t as it probably gives you other alternatives which definitely helps you at the time. Would you care if the search result was returned after 30 seconds of waiting? I bet you would be most certainly pissed about it. </p> <h3>Steak Case</h3> <p>If the onion ring case is a very well success, why didn’t they apply the same concept for the steak and serve it as fast as rings? The answer is very simple: serving the steak fast doesn’t make the customer happy if the steak is not cooked in a way the customer wants. The customer wants to tune the 'doneness' level of the steak and as long as they have it, it won’t matter if the serving time takes longer than the onion rings. Similar case applies to software applications, too. For instance, I would like to see my orders on amazon accurately all the time. Making them inaccurate just to serve the data fast would make me unhappy because I don’t care about how fast you are as long as it is a tolerable amount.</p> <h3>Conclusion</h3> <p>Let’s not pretend that every piece of data for our software application is the same. Well-tune the requirements, consider the trade offs and come up with a solid, functional plan to serve your data instead of blindly getting them out through the same door. If you are interested in this, make sure to read on <a href="http://en.wikipedia.org/wiki/Eventual_consistency">Eventually Consistency</a>. Also, looking into <a href="http://en.wikipedia.org/wiki/Domain-driven_design">Domain Driven Design</a> is another thing I would recommend.</p> <p>Finally, pointing to something new or making a point on what we generally do wrong is not the idea of the post here. It was about explaining the concept with a unique example.</p>  