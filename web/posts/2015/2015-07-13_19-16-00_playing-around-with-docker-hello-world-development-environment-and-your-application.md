---
title: 'Playing Around with Docker: Hello World, Development Environment and Your
  Application'
abstract: I have been also looking into Docker for a while now. In this post, I am
  planning to cover what made me love Docker and where it shines for me.
created_at: 2015-07-13 19:16:00 +0000 UTC
tags:
- Docker
- Linux
slugs:
- playing-around-with-docker-hello-world-development-environment-and-your-application
---

<p>When you have a urge to blog about something, it's mostly the case that you have just learnt something :) Well, it's the case for me now. I have been looking into Linux space for a while now and I didn't expect it to go this smooth. It is wonderful and I must admit that I have been missing on too many nice stuff by sticking with Windows for my development environment. However, I have one thing, one big thing that I have no regret at all: .NET ecosystem. It's one of the great ecosystems to write application on top and as it's now so easy to get it into non-Windows environments, the entry door for those environments are now wide open to me.</p> <p>I have been also looking into <a href="http://docker.com">Docker</a> for a while now and I was mostly trying to understand the concept as it's so distant to you if you were only developing on Windows for long time. After the concept was clear, the fun part started to take place. In this post, I am planning to cover that part and show you what made me love Docker.</p> <h3>Why Docker</h3> <p>Here is why I think Docker is useful for me (not much different than the other people's reasons):</p> <ul> <li>Repeatable, declarative environments. This can get much better with <a href="https://docs.docker.com/compose/">Docker compose</a> for your development, CI, QA (a.k.a. your Pre-Production) environments.&nbsp; <li>Read, try and tear down when you are learning a new tool like <a href="http://redis.io/">Redis</a>, <a href="https://www.rabbitmq.com/">RabbitMQ</a>, etc. Just run the <em>docker run</em> command and create the container. Play with the tools on that container and remove the container at the end. <li>One way of deploying stuff. AWS, Azure, whatever. Wherever you go, you will use the same script to deploy your stuff. <li>Shifting your thinking to modularize the hell out of your solution (microservices, there I said it). This can open up insane opportunities. For example, developing each part of your application with the stack that is suitable for the job. Not only you will preserve your sanity by using the right tool but also you will have different parts inside your solution which can be developed separately by separate people who has different skill sets. I strongly suggest <a href="http://www.dotnetrocks.com/default.aspx?showNum=1150">the .NET Rocks podcast on Building Microservices with Howard Dierking</a> to understand more about this. <li>I am not sure about this but Docker also makes it really trivial for people to dockerize repro environments for issues.</li></ul> <p>There will be possibly more by these are the stuff that made me love Docker.</p> <h3>Hello World</h3> <p>I will assume that you installed Docker and you are ready to go. In my case here, I am using Ubuntu 14.04 LTS but I assume it should be the same on OS X as well. </p> <p>As you can expect from Docker, the "Hello World" example is also declared and packaged up (A.K.A. dockerized). To get the "Hello World" example running, just run the below command:</p> <div class="code-wrapper border-shadow-1"> <div style="color: black; background-color: white"><pre>docker run ubuntu:14.04 <span style="color: gray">/</span>bin<span style="color: gray">/</span>echo <span style="color: #a31515">'Hello world'</span></pre></div></div>
<p>What happens when you do this is explained under <a href="https://docs.docker.com/userguide/dockerizing/#hello-world">Docker Hello World docs</a> but briefly, you have a container based on <a href="https://registry.hub.docker.com/_/ubuntu/">Ubuntu 14.04 image</a> and ran echo 'Hello World' in it and exited.</p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/a8d53416-2aab-4089-87ae-199a49b8daed.png"><img title="Screenshot from 2015-07-13 06^%10^%46" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%10^%46" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/8f12b236-58fa-4f90-acb4-c6081a21e3b9.png" width="644" height="243"></a></p>
<p>As mentioned, this container will not live after the echo is finished its job but it is still there to run. If you run the below command, you will see that container is there:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker ps <span style="color: gray">-</span>a</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/4ee4015e-ed70-4476-9d8b-78749b10e921.png"><img title="Screenshot from 2015-07-13 06^%11^%51" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%11^%51" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/1967d84f-8f21-42e1-9e9a-e1c052a89eeb.png" width="644" height="94"></a></p>
<p>We start the container by running the following command based on the container ID we retrieved from the <em>docker ps</em> output:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker start <span style="color: gray">--</span>attach 6a174ac370a2</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/98809c89-9dd2-4006-acc4-d94311697146.png"><img title="Screenshot from 2015-07-13 06^%17^%28" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%17^%28" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/97859ad9-64dc-4859-9962-4572b9594380.png" width="644" height="133"></a></p>
<p>We also used <a href="https://docs.docker.com/reference/commandline/start/">--attach switch</a> here to attach STDOUT/STDERR and forward signals and that's why we are able to see the hello world written in our console. Let's see a more realistic container example this time by getting an alive container up:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker run <span style="color: gray">-</span>d ubuntu:14.04 <span style="color: gray">/</span>bin<span style="color: gray">/</span>sh <span style="color: gray">-</span>c <span style="color: #a31515">"while true; do echo hello world; sleep 1; done"</span></pre></div></div>
<p>This example is the exact same example you can find on <a href="https://docs.docker.com/userguide/dockerizing/#a-daemonized-hello-world">"A daemonized Hello world" section of Docker Hello World doc</a>. The interesting stuff here is the -d switch which tells Docker to run the container and put it in the background. If we run <i>docker ps</i> now, we should see that the container is still at the running state:</p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/99592b56-adfa-4265-bbaf-5784177488ff.png"><img title="Screenshot from 2015-07-13 06^%38^%03" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%38^%03" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/857243f3-803c-4a75-8172-af7018b109dc.png" width="644" height="80"></a></p>
<p>We can attach to a running container's STDOUT/STDERR by running the below command based on the container ID:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker attach ff2847155ced</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/3bac6676-4d08-4be9-9a6f-7f40f6e397f2.png"><img title="Screenshot from 2015-07-13 06^%39^%43" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%39^%43" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/e6550f6e-2459-44d3-aeda-01e6eaa54e06.png" width="644" height="133"></a></p>
<p>You can detach from the container and leave it running with <i>CTRL-p CTRL-q</i>.</p>
<p>Also, you should have noticed that the first run command we have run took a while to get it up because it downloaded all the images from the registry. However, the second one was instantaneous as Ubuntu 14.04 was already there. So, we can understand from here that Docker images are immutable and composable which is great. You can look at the images you have under your host by running <i>docker images</i> command.</p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/816b2f5c-b9a4-472b-9f02-bf328951c4d8.png"><img title="Screenshot from 2015-07-13 06^%46^%10" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%46^%10" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/cd7f640c-bf9f-4aef-9612-df65ef6e7abb.png" width="644" height="72"></a></p>
<h3>Development Environment</h3>
<p>As mentioned before, Docker makes it super easy to get stuff in and try them out. For example, <a href="https://registry.hub.docker.com/_/redis/">Redis is on Docker registry</a> and I can just run it as another container:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker run <span style="color: gray">--</span>name my<span style="color: gray">-</span>redis <span style="color: gray">-</span>d redis:3.0.2</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/7826c2c1-f89a-434d-8358-af9596efbf62.png"><img title="Screenshot from 2015-07-13 06^%59^%06" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%59^%06" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/fd0b3859-2bb5-4583-a1f7-4ec1b242f011.png" width="644" height="177"></a></p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/70013322-ee87-492a-a919-93b515aecdd5.png"><img title="Screenshot from 2015-07-13 06^%59^%34" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 06^%59^%34" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/7809b9a8-111f-424e-b3d2-d18f2f00fab4.png" width="644" height="177"></a></p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/f7c8a6b4-2858-4a34-afe6-c46d5d1b6803.png"><img title="Screenshot from 2015-07-13 07^%01^%33" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 07^%01^%33" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/9eaccc1d-981c-4106-bc5e-73e466135dca.png" width="644" height="97"></a></p>
<p>I am seeing here that the TCP port 6379 is also exposed which is the port that Redis is exposed. However, I need to know the IP address of this host to connect to this Redis instance from the host. We can figure out the IP address of a running container through the <a href="https://docs.docker.com/reference/commandline/inspect/">inspect command</a>:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker inspect --format <span style="color: #a31515">'{{ .NetworkSettings.IPAddress }}'</span> dfaf0cf33467</pre></div></div>



<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/70797000-ab9e-4243-a6de-06e36141a1a3.png"><img title="Screenshot from 2015-07-13 07^%08^%10" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 07^%08^%10" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/ee0558f3-afef-47f2-82fb-b4b7c7760872.png" width="644" height="97"></a></p>
<p>Now, I can connect to this Redis instance with <a href="http://redis.io/commands">redis-cli tool</a> I have installed in my host:
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>redis<span style="color: gray">-</span>cli <span style="color: gray">-</span>h 172.17.0.10 <span style="color: gray">-</span>p 6379</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/acdcd75d-ed77-4fcf-bb84-76806dc66104.png"><img title="Screenshot from 2015-07-13 07^%13^%38" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 07^%13^%38" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/200a6f6a-684d-435b-ba6e-dd8aef6cf3d2.png" width="644" height="275"></a>
<p>I can play with this as long as I want and I can stop the container whenever I don't need it anymore. I can follow this process for nearly everything (e.g. Ruby, GoLang, Elasticsearch, MongoDB, RabbitMQ, you-name-your-thing, etc.). For example, get yourself a python development environment, you can run the following <em>docker run</em> command:
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker run <span style="color: gray">-</span>t <span style="color: gray">-</span>i python:2.7.10 <span style="color: gray">/</span>bin<span style="color: gray">/</span>bash</pre></div></div>
<p>This will get you <a href="https://docs.docker.com/userguide/dockerizing/#an-interactive-container">an interactive container</a> with Python installed in it and you can do anything you want with it:
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/5c7dc5a4-2037-40a8-a30a-3b6b3c9730c3.png"><img title="Screenshot from 2015-07-13 07^%37^%25" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 07^%37^%25" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/8c604d5c-f8fb-4a4d-9660-34776d23b8df.png" width="644" height="161"></a>
<p>When you’re done you can use the exit command or enter Ctrl-D to finish your interactive session inside the container and effectively stop the container. This container is still in your easy reach. You can start it again by obtaining its ID by running <a href="https://docs.docker.com/reference/commandline/ps/">docker ps -a</a> and running the <a href="https://docs.docker.com/reference/commandline/start/">start command</a> with the container ID.
<blockquote>
<p>You might wonder how tools like Redis, MongoDB and Elasticsearch fit into this world as they need to persist data on disk but Docker containers in nature are created and torn down without any worry. This is a well-thought problem and Docker has a solution for this problem with <a href="https://docs.docker.com/userguide/dockervolumes/">Data Volumes</a>.</p></blockquote>
<h3>Your Application</h3>
<p>This is all great and shiny but where does our application fit into this? There are some many different approaches that you can take with Docker for your application but let me show you a straight from and a powerful approach which will possibly give you an idea.</p>
<p>For an application example, I have chosen to dockerize <a href="https://github.com/OctopusDeploy/Library">Octopus Deploy Library web application</a> which works on top of <a href="https://nodejs.org/">Node.js</a>. The way to achieve this is through the <a href="https://docs.docker.com/reference/builder/">Dockerfile</a>. It has a well written documentation and here is how the Dockerfile for Octopus Deploy library would look like:</p>
<p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>FROM node:0.12.7

RUN <span style="color: gray">[</span><span style="color: teal">"npm", "install", "gulp", "-g"</span><span style="color: gray">]</span>
RUN <span style="color: gray">[</span><span style="color: teal">"npm", "install", "bower", "-g"</span><span style="color: gray">]</span>
RUN <span style="color: gray">[</span><span style="color: teal">"npm", "install", "grunt-cli", "-g"</span><span style="color: gray">]</span>

COPY . <span style="color: gray">/</span>app
WORKDIR <span style="color: gray">/</span>app

RUN <span style="color: gray">[</span><span style="color: teal">"npm", "install"</span><span style="color: gray">]</span>
RUN <span style="color: gray">[</span><span style="color: teal">"bower", "--allow-root", "install"</span><span style="color: gray">]</span>

EXPOSE 4000

ENTRYPOINT <span style="color: gray">[</span><span style="color: teal">"gulp"</span><span style="color: gray">]</span></pre></div></div></p>
<p>In my opinion, self-descriptiveness is the the best part of this file. We are defining here that the application image should be based on node:0.12.7 image, which has node.js stuff in it. Then, we run a few npm commands to install what we need. Later, we copy our stuff and change the working directory. Lastly, we install dependencies, expose the TCP port 4000 and specify the entry point command. </p>
<blockquote>
<p>Octopus Deploy does its magic and gets the server up when you run <em>gulp </em>default task. That's why it's our entry point here.</p></blockquote>
<p>We can now <a href="https://docs.docker.com/reference/commandline/build/">build</a> our application image:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker build <span style="color: gray">-</span>t octopus<span style="color: gray">-</span>library .</pre></div></div>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/3422f48b-8ecf-407b-acf7-3089aec61a5f.png"><img title="Screenshot from 2015-07-13 08^%33^%50" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 08^%33^%50" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/f054d198-f090-4b84-b1d9-30a8a1eca89b.png" width="644" height="211"></a></p>
<p>This kicks off the build and creates the image if everything goes well. Lastly, we can get the container up and running under our host using the same <em>run</em> command:</p>
<div class="code-wrapper border-shadow-1">
<div style="color: black; background-color: white"><pre>docker run <span style="color: gray">-</span>t <span style="color: gray">-</span>d <span style="color: gray">-</span>p 4040:4000 octopus<span style="color: gray">-</span>library</pre></div></div>
<p>We use -p option here to map the internal 4000 TCP port to 4040 TCP port of the host. With this way, you can access the running application from the host through 4040 TCP port:</p>
<p><a href="https://tugberkugurlu.blob.core.windows.net/bloggyimages/8dcfe0c3-6359-4ede-82d5-8de52d8e12e0.png"><img title="Screenshot from 2015-07-13 08^%50^%02" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="Screenshot from 2015-07-13 08^%50^%02" src="https://tugberkugurlu.blob.core.windows.net/bloggyimages/b71a004d-5898-481e-9535-cdbf571c88b2.png" width="644" height="356"></a></p>
<p>You can repeat the same steps by cloning <a href="https://github.com/tugberkugurlu/Library/tree/docker">my fork of Octopus Library and switching to docker branch</a>.
<h3>Resources</h3>
<ul>
<li><a href="https://coreos.com/docs/launching-containers/building/getting-started-with-docker/">Getting Started with Docker</a></li>
<li><a href="http://blog.benhall.me.uk/2015/06/running-docker-in-development-production-ndcoslo-2015/">Running Docker in Development &amp; Production (#ndcoslo 2015)</a>
<li><a href="http://blog.markrendle.net/fun-with-asp-net-5-and-docker/">Fun with ASP.NET 5, Linux &amp; Docker</a>
<li><a href="http://blog.markrendle.net/fun-with-asp-net-5-linux-docker-part-2/">Fun with ASP.NET 5, Linux &amp; Docker, Part 2</a>
<li><a href="http://blog.markrendle.net/fun-with-asp-net-5-linux-docker-part-3/">Fun with ASP.NET 5, Linux &amp; Docker, Part 3</a></li>
<li><a href="http://crosbymichael.com/dockerfile-best-practices.html">Dockerfile Best Practices</a></li>
<li><a href="https://github.com/wsargent/docker-cheat-sheet">Docker Cheat Sheet</a></li></ul>  